use super::{PublishedPackage, Source, Summary};
use crate::Project;
use anyhow::Context;
use cargo_metadata::camino::Utf8Path;
use cargo_metadata::semver::Version;
use git_cmd::Repo;
use regex::Regex;

pub struct GitTagsSource<'a> {
    project: &'a Project,
    repo: &'a Repo,
    tags: Vec<String>,
}

impl<'a> GitTagsSource<'a> {
    pub(crate) fn new(project: &'a Project, repo: &'a Repo) -> Self {
        Self {
            project,
            repo,
            tags: repo.get_all_tags(),
        }
    }
}

impl Source for GitTagsSource<'_> {
    fn query_latest<'a>(
        &'a self,
        package_name: &'a str,
    ) -> anyhow::Result<Option<impl Summary + 'a>> {
        // Find the package release tag corresponding to the greatest (i.e. latest) version
        let release_tag = filter_release_tags(
            self.tags.iter().map(AsRef::as_ref),
            package_name,
            self.project,
        )
        .max_by(|(_, a), (_, b)| a.cmp(b))
        .map(|(tag, version)| ReleaseTag {
            package_name,
            repo: self.repo,
            tag,
            version,
        });

        Ok(release_tag)
    }
}

/// Filters the release tags for the given package from all the `tags` in a repository.
///
/// Each item in the returned iterator is a tuple containing the name of the release tag and the
/// package version it corresponds to.
fn filter_release_tags<'t>(
    tags: impl Iterator<Item = &'t str> + 't,
    package: &'t str,
    project: &'t Project,
) -> impl Iterator<Item = (&'t str, Version)> + 't {
    // TODO: Consider using git tag template in the release-plz config at each tag, rather than
    // using the current template

    let version_var = crate::tera::tera_var(crate::tera::VERSION_VAR);

    // By substituting the version variable expression for the version variable,
    // we only render the package name (if needed) in the template
    let partial_template = project.git_tag(package, &version_var);

    // Escape the partially rendered template so that it can be used as a regex literal
    let fully_escaped_partial_template = regex::escape(&partial_template);

    // Replace the escaped version variable expression substring with the original un-escaped
    // expression string so we can use it as a template
    let escaped_partial_template =
        fully_escaped_partial_template.replace(&regex::escape(&version_var), &version_var);

    // Render template with version = "(.+)" to generate a regex which
    // captures the version string in a group
    let context = crate::tera::tera_context(package, r"(.+)");
    let release_tag_regex =
        crate::tera::render_template(&escaped_partial_template, &context, "release_tag_regex");
    // Add anchors to ensure regex matches whole string
    let release_tag_regex =
        Regex::new(&format!("^{release_tag_regex}$")).expect("invalid rendered version tag regex");

    tags.filter_map(move |tag| {
        // Check if the tag name matches the regex
        let (_, [version_str]) = release_tag_regex.captures(tag)?.extract();
        // Check if the captured version string can be parsed as a package version
        Some((tag, Version::parse(version_str).ok()?))
    })
}

struct ReleaseTag<'a> {
    package_name: &'a str,
    repo: &'a Repo,
    tag: &'a str,
    version: Version,
}

impl Summary for ReleaseTag<'_> {
    fn version(&self) -> &Version {
        &self.version
    }

    fn resolve(&self, temp_dir: &Utf8Path) -> anyhow::Result<PublishedPackage> {
        let package_store_dir = temp_dir.join(self.package_name);

        // "Download" each package into the temp dir.
        // We do this by simply creating a new worktree pointing to the release tag.
        // We could also do this in other ways:
        // 1. Find relative path to package manifest and checkout package contents
        //    (see git read-tree and checkout-index) into temp dir
        // 2. Use `cargo package` to create tarball, and extract it
        // But the simplest is to use a worktree

        // TODO: Untar tarball generated by `cargo package` so we have the proper format

        self.repo.add_worktree(&package_store_dir, self.tag)?;

        // TODO: Run git worktree prune somewhere after we are done

        // TODO: root Cargo.toml may not be in the repository root dir (see fs_utils::strip_prefix)
        let metadata =
            cargo_utils::get_manifest_metadata(&package_store_dir.join(cargo_utils::CARGO_TOML))
                .with_context(|| {
                    format!("failed to get root manifest metadata at tag '{}'", self.tag)
                })?;

        let published_package = metadata
            .packages
            .into_iter()
            .find(|p| p.name == self.package_name)
            .with_context(|| {
                format!(
                    "could not retrieve package '{}' in manifest at tag '{}'",
                    self.package_name, self.tag
                )
            })?;

        Ok(PublishedPackage {
            package: published_package,
            sha1: Some(self.repo.get_tag_commit(self.tag).with_context(|| {
                format!("release tag '{}' does not point to a commit", self.tag)
            })?),
        })
    }
}
